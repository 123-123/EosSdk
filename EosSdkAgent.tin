// Copyright (c) 2013 Arista Networks, Inc.  All rights reserved.
// Arista Networks, Inc. Confidential and Proprietary.

#include <dlfcn.h>

#include <iostream>

#include <Tac/Tracing.h>

#include "EosSdk/EosSdk.h"
#include "SDKInternal.h"

DEFAULT_TRACE_HANDLE( "EosSdkAgent" )

namespace EosSdk {

AdminDisabledReason convertAdminDisabledReason( const Tac::String& reason ) {
   // See IntfSM::handleStateChange in Intf/SysdbErrdisableIntf.tin
   if (reason.empty()) {
      return reasonEnabled;
   } else if (reason == "admin") {
      return reasonAdmin;
   } else if (reason == "errdisabled") {
      return reasonErrDisabled;
   } else if (reason == "inactive") {
      return reasonInactive;
   }
   return reasonUnknown;
}

static EosSdk::IntfId convert( Arnet::IntfId intfId ) {
   return EosSdk::IntfId( intfId.stringValue().stdString() );
}

void EthIntfConfigSm::handleDescription() {
   handler()->onDescription( convert( intfId() ),
                             ethIntfConfig()->description().stdString() );
}

void EthIntfConfigSm::handleAdminEnabled() {
   handler()->onAdminEnabled( convert( intfId() ),
                              ethIntfConfig()->adminEnabled() );
}

void EthIntfConfigSm::handleAdminDisabledReason() {
   AdminDisabledReason reason =
      convertAdminDisabledReason( ethIntfConfig()->enabledStateReason() );
   handler()->onAdminDisabledReason( convert( intfId() ), reason );
}

void SdkSm::handleEthIntfConfigDir( Arnet::IntfId intfId ) {
   TRACE8( __PRETTY_FUNCTION__ << " intfId=" << intfId );
   Interface::EthIntfConfig::PtrConst intfConfig =
      ethIntfConfigDir()->intfConfig( intfId );
   EosSdk::IntfId sdkIntfId = convert( intfId );
   if ( intfConfig ) {
      IntfHandler* intfHandler =
         handlers()->handleIntfCreation( sdk()->intfStatus( sdkIntfId ) );
      if ( intfHandler ) {
         TRACE7( __PRETTY_FUNCTION__ << " Created nested SM for " << intfId );
         ethIntfConfigSmIs( intfHandler, intfId, intfConfig );
      }
   } else {
      auto sm = ethIntfConfigSm( intfId );
      if ( sm ) {
         TRACE7( __PRETTY_FUNCTION__ << " Deleting nested SM for " << intfId );
         sm->handler()->onDeletion( sdkIntfId );
         ethIntfConfigSmDel( intfId );
      }
   }
}

void SdkSm::handleEthIntfStatusDir( Arnet::IntfId intfId ) {
   TRACE8( __PRETTY_FUNCTION__ << " intfId=" << intfId );
}

void SdkSm::handleEthPhyIntfConfigDir( Arnet::IntfId intfId ) {
   TRACE8( __PRETTY_FUNCTION__ << " intfId=" << intfId );
}

void SdkSm::handleEthPhyIntfStatusDir( Arnet::IntfId intfId ) {
   TRACE8( __PRETTY_FUNCTION__ << " intfId=" << intfId );
}

void
Agent::doInit() {
   TRACE8( __PRETTY_FUNCTION__ );

   Sysdb::MountGroup::Ptr mg = entityManager()->getMountGroup( this );

   mg->doMount( Sysdb::Mount( "interface/config/eth/intf",
                              "Interface::EthIntfConfigDir", "r" ) );
   mg->doMount( Sysdb::Mount( "interface/status/eth/intf",
                              "Interface::EthIntfStatusDir", "r" ) );

   mg->doMount( Sysdb::Mount( "interface/config/eth/phy",
                              "Interface::EthPhyIntfConfigDir", "r" ) );
   mg->doMount( Sysdb::Mount( "interface/status/eth/phy",
                              "Interface::EthPhyIntfStatusDir", "r" ) );

   mg->doClose( false, "", 0 );
}

void
Agent::doMountsComplete( Sysdb::MountStatus mountStatus,
                         Sysdb::EntityManager::Ptr const & em ) {
   TRACE8( __PRETTY_FUNCTION__ );
   assert( mountStatus == Sysdb::mountSuccess() );

   ethIntfConfigDirIs( em->getEntity<Interface::EthIntfConfigDir>(
            "interface/config/eth/intf" ) );
   ethIntfStatusDirIs( em->getEntity<Interface::EthIntfStatusDir>(
            "interface/status/eth/intf" ) );

   ethPhyIntfConfigDirIs( em->getEntity<Interface::EthPhyIntfConfigDir>(
            "interface/config/eth/phy" ) );
   ethPhyIntfStatusDirIs( em->getEntity<Interface::EthPhyIntfStatusDir>(
            "interface/status/eth/phy" ) );

   Tac::String app = extraArg()->extraArg( "app" );
   TRACE0( "Loading " << app );

   // Do we want RTLD_NOW | RTLD_GLOBAL?  I'd rather be lazy if we can.
   void * lib = dlopen( app.charPtr(), RTLD_LAZY );
   if ( !lib ) {
      std::cerr << "Failed to load `" << app << "': " << dlerror() << std::endl;
      abort();
   }
   TRACE0( "Loaded " << app );

   EosSdkInitFunc init = (EosSdkInitFunc) dlsym( lib, "EosSdkInit" );
   char* error = dlerror();
   if ( error ) {
      std::cerr << "Failed to get the `EosSdkInit' symbol: " << error << std::endl;
      abort();
   }

   SDKInternal* internal = new SDKInternal( this );
   sdkIs( internal->createSDK() );

   TRACE0( "Calling EosSdkInit from " << app );
   init( sdk() );

}

}  // namespace EosSdk
